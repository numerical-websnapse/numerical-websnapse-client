export const unicodeFormat = {
    rowMax: 3,
    prfMax: 1,

    bases: {
        a: "\u{1D44E}",
        b: "\u{1D44F}",
        c: "\u{1D450}",
        d: "\u{1D451}",
        e: "\u{1D452}",
        f: "\u{1D453}",
        g: "\u{1D454}",
        h: "\u{210E}",
        i: "\u{1D456}",
        j: "\u{1D457}",
        k: "\u{1D458}",
        l: "\u{1D459}",
        m: "\u{1D45A}",
        n: "\u{1D45B}",
        o: "\u{1D45C}",
        p: "\u{1D45D}",
        q: "\u{1D45E}",
        r: "\u{1D45F}",
        s: "\u{1D460}",
        t: "\u{1D461}",
        u: "\u{1D462}",
        v: "\u{1D463}",
        w: "\u{1D464}",
        x: "\u{1D465}",
        y: "\u{1D466}",
        z: "\u{1D467}",
        A: "\u{1D434}",
        B: "\u{1D435}",
        C: "\u{1D436}",
        D: "\u{1D437}",
        E: "\u{1D438}",
        F: "\u{1D439}",
        G: "\u{1D43A}",
        H: "\u{1D43B}",
        I: "\u{1D43C}",
        J: "\u{1D43D}",
        K: "\u{1D43E}",
        L: "\u{1D43F}",
        M: "\u{1D440}",
        N: "\u{1D441}",
        O: "\u{1D442}",
        P: "\u{1D443}",
        Q: "\u{1D444}",
        R: "\u{1D445}",
        S: "\u{1D446}",
        T: "\u{1D447}",
        U: "\u{1D448}",
        V: "\u{1D449}",
        W: "\u{1D44A}",
        X: "\u{1D44B}",
        Y: "\u{1D44C}",
        Z: "\u{1D44D}",
        1: "\u{1D7F7}",
        2: "\u{1D7F8}",
        3: "\u{1D7F9}",
        4: "\u{1D7FA}",
        5: "\u{1D7FB}",
        6: "\u{1D7FC}",
        7: "\u{1D7FD}",
        8: "\u{1D7FE}",
        9: "\u{1D7FF}",
        0: "\u{1D7F6}",
    },
    
    bold: {
        a: "\u{1D482}",
        b: "\u{1D483}",
        c: "\u{1D484}",
        d: "\u{1D485}",
        e: "\u{1D486}",
        f: "\u{1D487}",
        g: "\u{1D488}",
        h: "\u{1D489}",
        i: "\u{1D48A}",
        j: "\u{1D48B}",
        k: "\u{1D48C}",
        l: "\u{1D48D}",
        m: "\u{1D48E}",
        n: "\u{1D48F}",
        o: "\u{1D490}",
        p: "\u{1D491}",
        q: "\u{1D492}",
        r: "\u{1D493}",
        s: "\u{1D494}",
        t: "\u{1D495}",
        u: "\u{1D496}",
        v: "\u{1D497}",
        w: "\u{1D498}",
        x: "\u{1D499}",
        y: "\u{1D49A}",
        z: "\u{1D49B}",
        A: "\u{1D468}",
        B: "\u{1D469}",
        C: "\u{1D46A}",
        D: "\u{1D46B}",
        E: "\u{1D46C}",
        F: "\u{1D46D}",
        G: "\u{1D46E}",
        H: "\u{1D46F}",
        I: "\u{1D470}",
        J: "\u{1D471}",
        K: "\u{1D472}",
        L: "\u{1D473}",
        M: "\u{1D474}",
        N: "\u{1D475}",
        O: "\u{1D476}",
        P: "\u{1D477}",
        Q: "\u{1D478}",
        R: "\u{1D479}",
        S: "\u{1D47A}",
        T: "\u{1D47B}",
        U: "\u{1D47C}",
        V: "\u{1D47D}",
        W: "\u{1D47E}",
        X: "\u{1D47F}",
        Y: "\u{1D480}",
        Z: "\u{1D481}",
        0: "\u{1D7CE}",
        1: "\u{1D7CF}",
        2: "\u{1D7D0}",
        3: "\u{1D7D1}",
        4: "\u{1D7D2}",
        5: "\u{1D7D3}",
        6: "\u{1D7D4}",
        7: "\u{1D7D5}",
        8: "\u{1D7D6}",
        9: "\u{1D7D7}",
    },

    symbols: {
        "\\alpha": "\u{1D6FC}",
        "\\beta": "\u{1D6FD}",
        "\\gamma": "\u{1D6FE}",
        "\\delta": "\u{1D6FF}",
        "\\epsilon": "\u{1D700}",
        "\\zeta": "\u{1D701}",
        "\\eta": "\u{1D702}",
        "\\theta": "\u{1D703}",
        "\\iota": "\u{1D704}",
        "\\kappa": "\u{1D705}",
        "\\lambda": "\u{1D706}",
        "\\mu": "\u{1D707}",
        "\\nu": "\u{1D708}",
        "\\xi": "\u{1D709}",
        "\\pi": "\u{1D70B}",
        "\\rho": "\u{1D70C}",
        "\\sigma": "\u{1D70E}",
        "\\tau": "\u{1D70F}",
        "\\upsilon": "\u{1D710}",
        "\\phi": "\u{1D711}",
        "\\chi": "\u{1D712}",
        "\\psi": "\u{1D713}",
        "\\omega": "\u{1D714}",
        "\\Alpha": "\u{1D6E2}",
        "\\Beta": "\u{1D6E3}",
        "\\Gamma": "\u{0393}",
        "\\Delta": "\u{0394}",
        "\\Epsilon": "\u{1D716}",
        "\\Zeta": "\u{1D717}",
        "\\Eta": "\u{1D718}",
        "\\Theta": "\u{0398}",
        "\\Iota": "\u{1D71A}",
        "\\Kappa": "\u{1D71B}",
        "\\Lambda": "\u{039B}",
        "\\Mu": "\u{1D71D}",
        "\\Nu": "\u{1D71E}",
        "\\Xi": "\u{039E}",
        "\\Pi": "\u{03A0}",
        "\\Rho": "\u{1D71F}",
        "\\Sigma": "\u{03A3}",
        "\\Tau": "\u{1D720}",
        "\\Upsilon": "\u{03A5}",
        "\\Phi": "\u{03A6}",
        "\\Chi": "\u{1D722}",
        "\\Psi": "\u{03A8}",
        "\\Omega": "\u{03A9}",
        "\\infty": "\u{221E}",
        "\\rightarrow": "\u{2192}",
        "\\leftarrow": "\u{2190}",
        "\\leftrightarrow": "\u{2194}",
        "\\Rightarrow": "\u{21D2}",
        "\\Leftarrow": "\u{21D0}",
        "\\Leftrightarrow": "\u{21D4}",
        "\\sum": "\u{2211}",
        "\\prod": "\u{220F}",
        "\\int": "\u{222B}",
        "\\sqrt": "\u{221A}",
        "\\times": "\u{00D7}",
        "\\div": "\u{00F7}",
        "\\leq": "\u{2264}",
        "\\geq": "\u{2265}",
        "\\neq": "\u{2260}",
        "\\approx": "\u{2248}",
        "\\propto": "\u{221D}",
        "\\subseteq": "\u{2286}",
        "\\supseteq": "\u{2287}",
        "\\subset": "\u{2282}",
        "\\supset": "\u{2283}",
        "\\cup": "\u{222A}",
        "\\cap": "\u{2229}",
        "\\emptyset": "\u{2205}",
        "\\forall": "\u{2200}",
        "\\exists": "\u{2203}",
        "\\nabla": "\u{2207}",
        "\\pm": "\u{00B1}",
        "\\mp": "\u{2213}",
        "\\cdot": "\u{22C5}",
        "\\ldots": "\u{2026}",
        "\\cdots": "\u{22EF}",
        "\\vdots": "\u{22EE}",
        "\\ddots": "\u{22F1}",
    },

    subscripts: {
        0: "\u{2080}",
        1: "\u{2081}",
        2: "\u{2082}",
        3: "\u{2083}",
        4: "\u{2084}",
        5: "\u{2085}",
        6: "\u{2086}",
        7: "\u{2087}",
        8: "\u{2088}",
        9: "\u{2089}",
        "-": "\u{208B}",
        "(": "\u{208D}",
        ")": "\u{208E}",
        "/": "\u{2E1D}",
        ",": ",",
        ".": ".",
    },

    nameFormat: (content) => {
        let unicodeContent = '';

        const {
            bases,
            subscripts,
            symbols
        } = unicodeFormat;
        
        Object.keys(symbols).forEach(latex => {
            const regex = new RegExp(latex.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
            content = content.replace(regex, symbols[latex]);
        });
        
        const symbolsArray = Object.values(symbols);

        if (content.includes('_')) {
            let [base, sub] = content.split('_');
            
            sub = [...sub].map((v, i) => {
                return subscripts[v];
            }).join('');
            
            base = [...base].map((v, i) => {
                if (symbolsArray.includes(v)) return v;
                return bases[v];
            }).join('');

            unicodeContent = `${base}${sub}`;
        } else {
            unicodeContent = [...content].map((v, i) => {
                if (symbolsArray.includes(v)) return v;
                return bases[v];
            }).join('');
        }

        return unicodeContent;
    },

    singleFormatVar: (name, value) => {
        const { nameFormat } = unicodeFormat;
        let string = value[0];
        string = string.replace('-', '\u{2212}');
        return `${nameFormat(name)}[${string}]`;
    },

    rowFormatVar: (row) => {
        return row.join(`, `);
    },

    singleFormatPrf: (name, value) => {
        const { 
            subscripts,
            nameFormat
        } = unicodeFormat;
        
        const expression = value[1].reduce(function(p, d, i) {
            const val = d[1];

            // if value is 0, return empty string if first value, else return previous value
            if (val === '0') {
                if (i === 0) return '';
                return p;
            };
            
            // assume val is a string that can be formatted as int, float, or fraction  (from regex check)
            const isNegative = val[0] === '-';
            const coef = isNegative ? val.slice(1) : val;
            
            // wrap coefficient if its a fraction or decimal
            // if fraction, wrap in \frac{}{}, split by '/'
            // check if value is 1 or -1
            const isFraction = coef.includes('/');
            const isDecimal = coef.includes('.');
            const isOne = coef === '1';
            let coefWrap = isOne ? '' : coef;
            // if (isFraction) {
            //     const [num, den] = coef.split('/');
            //     coefChk = `\\left(\\frac{${num}}{${den}}\\right)`;   // wrap in \frac{}{}
            // }
            // if (isDecimal) {
            //     coefChk = `(${coefChk})`;                            // wrap in ()
            // }
            coefWrap = isFraction || isDecimal ? `(${coefWrap})` : coefWrap;
            const op = isNegative ? ` \u{2212} ${coefWrap}` : ( !p ? `${coefWrap}` : ` + ${coefWrap}`);
            const var_ = op + nameFormat(d[0]);
            
            if (i === 0) return '' + var_;
            return p + var_;
        }, 0);

        const threshold = value[0] ? `âˆ£${[...value[0]].map((v, i) => {
            return subscripts[v];
        }).join('')}` : '';

        if (expression === '') return `${nameFormat(name)} = 0${threshold}`;
        return `${nameFormat(name)} = ${expression}${threshold}`;
    },

    rowFormatPrf: (row) => {
        return row.join('\n');
    },

    trainFormat: (content, details) => {
        let { row, supress=null, count=null, reverse=false } = details;
        
        let accumulator = '';
        let compressed = content;
        row = row < 1 ? 5 : row;

        if (supress) {
            if(reverse) compressed = content.slice(0,count);
            else compressed = content.slice(-count);
        }
            
        compressed.forEach((t, i) => {
            accumulator += `${t}`;
            if((i+1) % row && (i+1) !== compressed.length) accumulator += `, `;
            if (!((i+1) % row) && (i+1) !== compressed.length) accumulator += `\n`;
        });
        
        return accumulator;
    }
};
